{"version":3,"sources":["AutoComplete/AutoComplete.service.ts","AutoComplete/AutoComplete.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["axiosInstance","axios","create","baseURL","timeout","headers","AutoComplete","props","state","isLoading","suggestions","undefined","onUserInput","bind","e","userQuery","this","setState","target","value","method","url","params","q","then","response","data","catch","className","autoComplete","type","id","name","placeholder","onChange","_","debounce","map","suggestion","index","href","onClick","onSelectItem","React","Component","App","alert","currentTarget","text","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"sTAEMA,E,OAAgBC,EAAMC,OAAO,CACjCC,QAAS,6CACTC,QAAS,IACTC,QAAS,CACP,eAAgB,oCAChB,8BAA+B,O,eC4EpBC,E,kDAnEb,WAAYC,GAA4B,IAAD,8BACrC,cAAMA,IACDC,MAAQ,CACXC,WAAW,EACXC,iBAAaC,GAGf,EAAKC,YAAc,EAAKA,YAAYC,KAAjB,gBAPkB,E,+CAWvC,SAAYC,GAA+C,IDhBxBC,ECgBuB,QACxDC,KAAKC,SAAS,CACZR,WAAW,EACXC,iBAAaC,IAGVG,EAAEI,OAAOC,QDtBmBJ,EC0BZD,EAAEI,OAAOC,MDzBzBnB,EAAc,CACnBoB,OAAQ,MACRC,IAAK,SACLC,OAAQ,CACNC,EAAGR,KAEJS,MAAK,SAACC,GACP,OAAOA,EAASC,QACfC,OAAM,SAACb,GAER,MAAO,CAAC,aCe6BU,MAAK,SAACE,GACzC,EAAKT,SAAS,CACZR,WAAW,EACXC,YAAagB,OANfV,KAAKC,SAAS,CAAER,WAAW,M,oBAW/B,WAAU,IAAD,OACP,OACE,sBAAKmB,UAAU,UAAf,UACE,qBAAKA,UAAS,UAAKZ,KAAKR,MAAMC,UAAY,aAAe,GAA3C,YAAd,SACE,sBAAKmB,UAAU,kBAAf,UAEE,uBACEC,aAAa,MACbD,UAAU,cACVE,KAAK,SAASC,GAAG,eACjBC,KAAK,SACLC,YAAY,SACZC,SAAUC,IAAEC,SAASpB,KAAKJ,YAAa,OACzC,qBAAKgB,UAAU,iBAAf,SACE,mBAAGA,UAAU,kBAMlBZ,KAAKR,MAAME,aAGZ,qBAAKkB,UAAU,OAAf,SACGZ,KAAKR,MAAME,YAAY2B,KAAI,SAACC,EAAoBC,GAC/C,OACE,mBAAeX,UAAU,YAAYY,KAAK,IAAIC,QAAS,EAAKlC,MAAMmC,aAAlE,SACGJ,GADKC,e,GAxDKI,IAAMC,W,MCKlBC,MAff,WAKE,OACE,sBAAKjB,UAAU,MAAf,UACE,wBAAQA,UAAU,aAAlB,iCAGA,cAAC,EAAD,CAAcc,aATH,SAAC5B,GACdgC,MAAM,qBAAuBhC,EAAEiC,cAAcC,aCOlCC,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,6BAAqB3B,MAAK,YAAkD,IAA/C4B,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOF,GACPG,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAQN,OCHdO,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1BZ,M","file":"static/js/main.3466da6f.chunk.js","sourcesContent":["import axios from 'axios'\n\nconst axiosInstance = axios.create({\n  baseURL: 'https://dry-cliffs-99602.herokuapp.com/api',\n  timeout: 1000,\n  headers: {\n    'Content-Type': 'application/x-www-form-urlencoded',\n    'Access-Control-Allow-Origin': '*',\n  }\n})\n\nexport const getSearchSuggestions = (userQuery: string): Promise<string[]> => {\n  return axiosInstance({\n    method: 'get',\n    url: '/items',\n    params: {\n      q: userQuery,\n    }\n  }).then((response: any) => {\n    return response.data\n  }).catch((e: object) => {\n    // Exercise assumption was that API would never return an error. Used this for testing purposes.\n    return ['error']\n  })\n}\n","import React from 'react'\nimport _ from 'lodash'\n\nimport { getSearchSuggestions } from './AutoComplete.service'\nimport './AutoComplete.css'\n\ninterface IAutoCompleteProps {\n  onSelectItem: (e: React.MouseEvent<HTMLAnchorElement, MouseEvent>) => void\n}\n\ninterface IAutoCompleteState {\n  isLoading: boolean\n  suggestions?: string[]\n}\n\nclass AutoComplete extends React.Component<IAutoCompleteProps, IAutoCompleteState> {\n  constructor(props: IAutoCompleteProps) {\n    super(props)\n    this.state = {\n      isLoading: false,\n      suggestions: undefined,\n    }\n\n    this.onUserInput = this.onUserInput.bind(this)\n  }\n  \n  // Method debounced as part of onInput event in render() - only called 500ms after last user input\n  onUserInput(e: React.ChangeEvent<HTMLInputElement>): void {\n    this.setState({\n      isLoading: true,\n      suggestions: undefined,\n    })\n    // Clears suggestions and loading wheel if input field is cleared\n    if (!e.target.value) {\n      this.setState({ isLoading: false })\n      return\n    }\n    getSearchSuggestions(e.target.value).then((data: any) => {\n      this.setState({\n        isLoading: false,\n        suggestions: data,\n      })\n    })\n  }\n\n  render() {    \n    return (\n      <div className='wrapper'>\n        <div className={`${this.state.isLoading ? 'is-loading' : ''} control`}>\n          <div className='input-container'>\n            {/* Disabling browser autocomplete so this autosuggestion isn't conflicting in the UI */}\n            <input\n              autoComplete='off'\n              className='input-field'\n              type='search' id='search-input'\n              name='search'\n              placeholder='Search'\n              onChange={_.debounce(this.onUserInput, 500)} />\n            <div className='icon-container'>\n              <i className='loader'></i>\n            </div>\n          </div>\n          {/* Submit button not included as part of this component - not included in the exercise example */}\n\n        </div>\n        {this.state.suggestions && \n        // If this were my own feature, I would make this a <ul> with <li> elements, but the example displayed this as a div and <a> tags (without hrefs) for each list item\n        // List only rendered if suggestions is populated with data\n        <div className='list'>\n          {this.state.suggestions.map((suggestion: string, index: number): JSX.Element => {\n            return (\n              <a key={index} className='list-item' href='/' onClick={this.props.onSelectItem}>\n                {suggestion}\n              </a>\n            )\n          })}\n        </div>\n        }\n    </div>\n    )\n  }\n}\n\nexport default AutoComplete","import React from 'react'\nimport AutoComplete from './AutoComplete/AutoComplete'\n\nimport './App.css'\n\nfunction App() {\n  const select = (e: React.MouseEvent<HTMLAnchorElement, MouseEvent>) => {\n    alert('You have selected ' + e.currentTarget.text)\n  }\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        AutoComplete Search\n      </header>\n      <AutoComplete onSelectItem={select} />\n    </div>\n  )\n}\n\nexport default App\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\nimport reportWebVitals from './reportWebVitals'\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals()\n"],"sourceRoot":""}